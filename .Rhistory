}
return(list(chain1, chain2, cellType))
}
#Producing a data frame to visualize for lengthContig()
lengthDF <- function(df, cloneCall, chain, group, c1, c2){
Con.df <- NULL
names <- names(df)
if (chain == "both") {
for (i in seq_along(df)) {
length <- nchar(gsub("_", "", df[[i]][,cloneCall]))
val <- df[[i]][,cloneCall]
if (!is.null(group)) {
cols <- df[[i]][,group]
data <- na.omit(data.frame(length, val, cols, names[i]))
colnames(data) <- c("length", "CT", group, "values")
Con.df<- rbind.data.frame(Con.df, data)
} else {
data <- na.omit(data.frame(length, val, names[i]))
colnames(data) <- c("length", "CT", "values")
Con.df<- rbind.data.frame(Con.df, data) }}
} else if (chain != "both") {
for (x in seq_along(df)) {
df[[x]] <- off.the.chain(df[[x]], chain, cloneCall)
strings <- df[[x]][,cloneCall]
val1 <- strings
for (i in seq_along(val1)) {
if (grepl(";", val1[i]) == TRUE) {
val1[i] <- str_split(val1[i], ";", simplify = TRUE)[1]
} else { next() } }
chain1 <- nchar(val1)
if (!is.null(group)) {
cols1 <- df[[x]][,group]
data1 <- data.frame(chain1, val1, names[x], c1, cols1)
colnames(data1)<-c("length","CT","values","chain",group)
}else if (is.null(group)){
data1 <- data.frame(chain1, val1, names[x], c1)
colnames(data1) <- c("length", "CT", "values", "chain")
data <- na.omit(data1)
data <- subset(data, CT != "NA" & CT != "")
Con.df<- rbind.data.frame(Con.df, data) }}
}
return(Con.df)}
#General combination of nucleotide, aa, and gene sequences for T/B cells
assignCT <- function(cellType, Con.df) {
if (cellType %in% c("T-AB", "T-GD")) {
Con.df$CTgene <- paste(Con.df$TCR1, Con.df$TCR2, sep="_")
Con.df$CTnt <- paste(Con.df$cdr3_nt1, Con.df$cdr3_nt2, sep="_")
Con.df$CTaa <- paste(Con.df$cdr3_aa1, Con.df$cdr3_aa2, sep="_")
Con.df$CTstrict <- paste(Con.df$TCR1, Con.df$cdr3_nt1,
Con.df$TCR2, Con.df$cdr3_nt2, sep="_")
} else {
Con.df$CTgene <- paste(Con.df$IGH, Con.df$IGLC, sep="_")
Con.df$CTnt <- paste(Con.df$cdr3_nt1, Con.df$cdr3_nt2, sep="_")
Con.df$CTaa <- paste(Con.df$cdr3_aa1, Con.df$cdr3_aa2, sep="_") }
return(Con.df)
}
#Sorting the V/D/J/C gene sequences for T and B cells
#' @importFrom stringr str_c
makeGenes <- function(cellType, data2, chain1, chain2) {
if(cellType %in% c("T-AB", "T-GD")) {
data2 <- data2 %>%
mutate(TCR1 = ifelse(chain == chain1,
str_c(v_gene,  j_gene, c_gene, sep = "."), NA)) %>%
mutate(TCR2 = ifelse(chain == chain2,
str_c(v_gene, d_gene,  j_gene,  c_gene, sep = "."), NA))
}
else {
data2 <- data2 %>%
mutate(IGKct = ifelse(chain == "IGK",
str_c(v_gene,  j_gene, c_gene, sep = "."), NA)) %>%
mutate(IGLct = ifelse(chain == "IGL",
str_c(v_gene,  j_gene, c_gene, sep = "."), NA)) %>%
mutate(IGHct = ifelse(chain == "IGH",
str_c(v_gene, d_gene,  j_gene,  c_gene, sep = "."), NA))
}
return(data2)
}
short.check <- function(df, cloneCall) {
min <- c()
for (x in seq_along(df)) {
min.tmp <- length(which(!is.na(unique(df[[x]][,cloneCall]))))
min <- c(min.tmp, min)
}
min <- min(min)
return(min)
}
select.gene <- function(df, chain, gene, label) {
if (chain %in% c("TRB", "TRG", "IGH")) {
gene <- unname(c(V = 1, D = 2, J = 3, C = 4)[gene])
} else {
gene <- unname(c(V = 1, J = 2, C = 3)[gene])
}
if (ncol(str_split(df[,"CTgene"], "_", simplify = TRUE)) == 1) {
C1 <- str_split(df[,"CTgene"], "_", simplify = TRUE)[,1]
C1 <- str_split(C1, "[.]", simplify = TRUE)[,gene]
df$C1 <- C1
x <- "C1"
} else {
C1 <- str_split(df[,"CTgene"], "_", simplify = TRUE)[,1]
C1 <- str_split(C1, "[.]", simplify = TRUE)[,gene]
C2 <- str_split(df[,"CTgene"], "_", simplify = TRUE)[,2]
C2 <- str_split(C2, "[.]", simplify = TRUE)[,gene]
df$C1 <- C1
df$C2 <- C2
if (chain %in% c("TRA", "TRD", "IGH")) {
x <- "C1"}
else if (chain %in% c("TRB", "TRG", "IGL")) {
x <- "C2"}
}
return(df)
}
df <- checkList(df)
out <- NULL
final <- list()
chain1 <- "heavy"
chain2 <- "light"
for (i in seq_along(df)) {
df[[i]] <- subset(df[[i]], chain %in% c("IGH", "IGK", "IGL"))
df[[i]] <- subset(df[[i]], productive %in% c(TRUE, "TRUE", "True", "true"))
if (nrow(df[[i]]) == 0) { stop("There are 0 contigs
after internal filtering - check the contig list to see
if any issues exist for productive chains", call. = FALSE) }
df[[i]] <- df[[i]] %>% group_by(barcode,chain) %>% top_n(n=1,wt=reads)
for (i in seq_along(df)) {
df[[i]] <- subset(df[[i]], chain %in% c("IGH", "IGK", "IGL"))
df[[i]] <- subset(df[[i]], productive %in% c(TRUE, "TRUE", "True", "true"))
#if (nrow(df[[i]]) == 0) { stop("There are 0 contigs
#        after internal filtering - check the contig list to see
#        if any issues exist for productive chains", call. = FALSE) }
df[[i]] <- df[[i]] %>% group_by(barcode,chain) %>% top_n(n=1,wt=reads)
df[[i]]$sample <- samples[i]
df[[i]]$ID <- ID[i]
df[[i]] <- filteringMulti(df[[i]]) }
for (i in seq_along(df)) {
df[[i]] <- subset(df[[i]], chain %in% c("IGH", "IGK", "IGL"))
df[[i]] <- subset(df[[i]], productive %in% c(TRUE, "TRUE", "True", "true"))
#if (nrow(df[[i]]) == 0) { stop("There are 0 contigs
#        after internal filtering - check the contig list to see
#        if any issues exist for productive chains", call. = FALSE) }
df[[i]] <- df[[i]] %>% group_by(barcode,chain) %>% top_n(n=1,wt=reads)
df[[i]]$sample <- samples[i]
df[[i]]$ID <- ID[i]
df[[i]] <- filteringMulti(df[[i]]) }
library(dplyr)
for (i in seq_along(df)) {
df[[i]] <- subset(df[[i]], chain %in% c("IGH", "IGK", "IGL"))
df[[i]] <- subset(df[[i]], productive %in% c(TRUE, "TRUE", "True", "true"))
#if (nrow(df[[i]]) == 0) { stop("There are 0 contigs
#        after internal filtering - check the contig list to see
#        if any issues exist for productive chains", call. = FALSE) }
df[[i]] <- df[[i]] %>% group_by(barcode,chain) %>% top_n(n=1,wt=reads)
df[[i]]$sample <- samples[i]
df[[i]]$ID <- ID[i]
df[[i]] <- filteringMulti(df[[i]]) }
df <- checkList(df)
out <- NULL
final <- list()
chain1 <- "heavy"
chain2 <- "light"
for (i in seq_along(df)) {
df[[i]] <- subset(df[[i]], chain %in% c("IGH", "IGK", "IGL"))
df[[i]] <- subset(df[[i]], productive %in% c(TRUE, "TRUE", "True", "true"))
#if (nrow(df[[i]]) == 0) { stop("There are 0 contigs
#        after internal filtering - check the contig list to see
#        if any issues exist for productive chains", call. = FALSE) }
df[[i]] <- df[[i]] %>% group_by(barcode,chain) %>% top_n(n=1,wt=reads)
df[[i]]$sample <- samples[i]
if (!is.null(ID)) {
df[[i]]$ID <- ID[i]
}
df[[i]] <- filteringMulti(df[[i]]) }
ID = NULL
for (i in seq_along(df)) {
df[[i]] <- subset(df[[i]], chain %in% c("IGH", "IGK", "IGL"))
df[[i]] <- subset(df[[i]], productive %in% c(TRUE, "TRUE", "True", "true"))
#if (nrow(df[[i]]) == 0) { stop("There are 0 contigs
#        after internal filtering - check the contig list to see
#        if any issues exist for productive chains", call. = FALSE) }
df[[i]] <- df[[i]] %>% group_by(barcode,chain) %>% top_n(n=1,wt=reads)
df[[i]]$sample <- samples[i]
if (!is.null(ID)) {
df[[i]]$ID <- ID[i]
}
df[[i]] <- filteringMulti(df[[i]]) }
out <- modifyBarcodes(df, samples, ID)
for (i in seq_along(out)) {
data2 <- data.frame(out[[i]])
data2 <- makeGenes(cellType = "B", data2)
unique_df <- unique(data2$barcode)
Con.df <- data.frame(matrix(NA, length(unique_df), 9))
colnames(Con.df) <- c("barcode", heavy_lines, light_lines)
Con.df$barcode <- unique_df
Con.df <- parseBCR(Con.df, unique_df, data2)
Con.df <- assignCT(cellType = "B", Con.df)
data3<-Con.df %>% mutate(length1 = nchar(cdr3_nt1)) %>%
mutate(length2 = nchar(cdr3_nt2))
final[[i]] <- data3 }
library(stringr)
for (i in seq_along(out)) {
data2 <- data.frame(out[[i]])
data2 <- makeGenes(cellType = "B", data2)
unique_df <- unique(data2$barcode)
Con.df <- data.frame(matrix(NA, length(unique_df), 9))
colnames(Con.df) <- c("barcode", heavy_lines, light_lines)
Con.df$barcode <- unique_df
Con.df <- parseBCR(Con.df, unique_df, data2)
Con.df <- assignCT(cellType = "B", Con.df)
data3<-Con.df %>% mutate(length1 = nchar(cdr3_nt1)) %>%
mutate(length2 = nchar(cdr3_nt2))
final[[i]] <- data3 }
dictionary <- bind_rows(final)
IGH <- lvCompare(dictionary, "IGH", "cdr3_nt1", threshold)
# Calculates the normalized Levenshtein Distance between the contig
# nucleotide sequence.
#' @importFrom stringdist stringdistmatrix
#' @importFrom igraph graph_from_data_frame components
lvCompare <- function(dictionary, gene, chain, threshold) {
overlap <- NULL
out <- NULL
tmp <- na.omit(unique(dictionary[,chain]))
length <- nchar(tmp)
dist <- stringdistmatrix(tmp, method = "lv")
edge.list <- NULL
for (j in seq_len(length(tmp))) {
row <- SliceExtract_dist(dist,j)
norm.row <- row
for (k in seq_len(length(norm.row))) {
norm.row[k] <- 1- (norm.row[k]/mean(c(length[j],length[k])))
}
neighbor <- which(norm.row >= threshold)
knn.norm = data.frame("from" = j,
"to" = neighbor)
edge.list <- rbind(edge.list, knn.norm)
}
if (nrow(edge.list) > 0) {
edge.list <- unique(edge.list)
g <- graph_from_data_frame(edge.list)
components <- components(g, mode = c("weak"))
out <- data.frame("cluster" = components$membership,
"filtered" = names(components$membership))
filter <- which(table(out$cluster) > 1)
out <- subset(out, cluster %in% filter)
out$cluster <- paste0(gene, ":LD", ".", out$cluster)
out$filtered <- tmp[as.numeric(out$filtered)]
uni_IG <- as.data.frame(unique(tmp[tmp %!in% out$filtered]))
colnames(uni_IG) <- "filtered"
uni_IG$cluster <- paste0(gene, ".", seq_len(nrow(uni_IG)))
}
output <- rbind.data.frame(out, uni_IG)
colnames(output) <- c("Hclonotype", "IG")
return(output)
}
IGH <- lvCompare(dictionary, "IGH", "cdr3_nt1", threshold)
library(stringdist)
IGH <- lvCompare(dictionary, "IGH", "cdr3_nt1", threshold)
#Code from https://stackoverflow.com/questions/57282842/how-to-efficiently-extract-a-row-or-column-from-a-dist-distance-matrix?rq=1
SliceExtract_dist <- function (dist_obj, k) {
if (length(k) > 1) stop("The function is not 'vectorized'!")
n <- attr(dist_obj, "Size")
if (k < 1 || k > n) stop("k out of bound!")
##
i <- 1:(k - 1)
j <- rep.int(k, k - 1)
v1 <- dist_obj[f(j, i, dist_obj)]
##
i <- (k + 1):n
j <- rep.int(k, n - k)
v2 <- dist_obj[f(i, j, dist_obj)]
##
c(v1, 0, v2)
}
#Code from https://stackoverflow.com/questions/57282842/how-to-efficiently-extract-a-row-or-column-from-a-dist-distance-matrix?rq=1
f <- function (i, j, dist_obj) {
if (!inherits(dist_obj, "dist")) stop("please provide a 'dist' object")
n <- attr(dist_obj, "Size")
valid <- (i >= 1) & (j >= 1) & (i > j) & (i <= n) & (j <= n)
k <- (2 * n - j) * (j - 1) / 2 + (i - j)
k[!valid] <- NA_real_
k
}
IGH <- lvCompare(dictionary, "IGH", "cdr3_nt1", threshold)
threshold = 0.85
IGH <- lvCompare(dictionary, "IGH", "cdr3_nt1", threshold)
library(igraph)
IGH <- lvCompare(dictionary, "IGH", "cdr3_nt1", threshold)
"%!in%" <- Negate("%in%")
IGH <- lvCompare(dictionary, "IGH", "cdr3_nt1", threshold)
IGLC <- lvCompare(dictionary, "IGLC", "cdr3_nt2", threshold)
gene = ""IGH""
gene = "IGH"
chain = "cdr3_nt1"
overlap <- NULL
out <- NULL
tmp <- na.omit(unique(dictionary[,chain]))
length <- nchar(tmp)
dist <- stringdistmatrix(tmp, method = "lv")
edge.list <- NULL
for (j in seq_len(length(tmp))) {
row <- SliceExtract_dist(dist,j)
norm.row <- row
for (k in seq_len(length(norm.row))) {
norm.row[k] <- 1- (norm.row[k]/mean(c(length[j],length[k])))
}
neighbor <- which(norm.row >= threshold)
knn.norm = data.frame("from" = j,
"to" = neighbor)
edge.list <- rbind(edge.list, knn.norm)
}
if (nrow(edge.list) > 0) {
edge.list <- unique(edge.list)
g <- graph_from_data_frame(edge.list)
components <- components(g, mode = c("weak"))
out <- data.frame("cluster" = components$membership,
"filtered" = names(components$membership))
filter <- which(table(out$cluster) > 1)
out <- subset(out, cluster %in% filter)
out$cluster <- paste0(gene, ":LD", ".", out$cluster)
out$filtered <- tmp[as.numeric(out$filtered)]
uni_IG <- as.data.frame(unique(tmp[tmp %!in% out$filtered]))
colnames(uni_IG) <- "filtered"
uni_IG$cluster <- paste0(gene, ".", seq_len(nrow(uni_IG)))
}
edge.list <- NULL
for (j in seq_len(length(tmp))) {
row <- SliceExtract_dist(dist,j)
norm.row <- row
for (k in seq_len(length(norm.row))) {
norm.row[k] <- 1- (norm.row[k]/mean(c(length[j],length[k])))
}
neighbor <- which(norm.row >= threshold)
knn.norm = data.frame("from" = j,
"to" = neighbor)
edge.list <- rbind(edge.list, knn.norm)
}
nrow(edge.list)
edge.list <- unique(edge.list)
g <- graph_from_data_frame(edge.list)
components <- components(g, mode = c("weak"))
out <- data.frame("cluster" = components$membership,
"filtered" = names(components$membership))
filter <- which(table(out$cluster) > 1)
out <- subset(out, cluster %in% filter)
out$cluster <- paste0(gene, ":LD", ".", out$cluster)
out$filtered <- tmp[as.numeric(out$filtered)]
uni_IG <- as.data.frame(unique(tmp[tmp %!in% out$filtered]))
colnames(uni_IG) <- "filtered"
View(uni_IG)
uni_IG <- as.data.frame(unique(tmp[tmp %!in% out$filtered]))
colnames(uni_IG) <- "filtered"
uni_IG$cluster <- paste0(gene, ".", seq_len(nrow(uni_IG)))
output <- rbind.data.frame(out, uni_IG)
# Calculates the normalized Levenshtein Distance between the contig
# nucleotide sequence.
#' @importFrom stringdist stringdistmatrix
#' @importFrom igraph graph_from_data_frame components
lvCompare <- function(dictionary, gene, chain, threshold) {
overlap <- NULL
out <- NULL
tmp <- na.omit(unique(dictionary[,chain]))
length <- nchar(tmp)
dist <- stringdistmatrix(tmp, method = "lv")
edge.list <- NULL
for (j in seq_len(length(tmp))) {
row <- SliceExtract_dist(dist,j)
norm.row <- row
for (k in seq_len(length(norm.row))) {
norm.row[k] <- 1- (norm.row[k]/mean(c(length[j],length[k])))
}
neighbor <- which(norm.row >= threshold)
knn.norm = data.frame("from" = j,
"to" = neighbor)
edge.list <- rbind(edge.list, knn.norm)
}
if (nrow(edge.list) > 0) {
edge.list <- unique(edge.list)
g <- graph_from_data_frame(edge.list)
components <- components(g, mode = c("weak"))
out <- data.frame("cluster" = components$membership,
"filtered" = names(components$membership))
filter <- which(table(out$cluster) > 1)
out <- subset(out, cluster %in% filter)
out$cluster <- paste0(gene, ":LD", ".", out$cluster)
out$filtered <- tmp[as.numeric(out$filtered)]
uni_IG <- as.data.frame(unique(tmp[tmp %!in% out$filtered]))
colnames(uni_IG) <- "filtered"
if (nrow(uni_IG) > 0) {
uni_IG$cluster <- paste0(gene, ".", seq_len(nrow(uni_IG)))
}
}
output <- rbind.data.frame(out, uni_IG)
colnames(output) <- c("Hclonotype", "IG")
return(output)
}
IGH <- lvCompare(dictionary, "IGH", "cdr3_nt1", threshold)
IGLC <- lvCompare(dictionary, "IGLC", "cdr3_nt2", threshold)
#' @param df List of filtered contig annotations from 10x Genomics.
#' @param samples The labels of samples (required).
#' @param ID The additional sample labeling (optional).
#' @param threshold The normalized edit distance to consider. The higher the number the more
#' similarity of sequence will be used for clustering.
#' @param removeNA This will remove any chain without values.
#' @param removeMulti This will remove barcodes with greater than 2 chains.
#' @import dplyr
#' @export
#' @return List of clonotypes for individual cell barcodes
combineBCR <- function(df, samples = NULL, ID = NULL,
threshold = 0.85,
removeNA = FALSE,
removeMulti = FALSE) {
df <- checkList(df)
out <- NULL
final <- list()
chain1 <- "heavy"
chain2 <- "light"
for (i in seq_along(df)) {
df[[i]] <- subset(df[[i]], chain %in% c("IGH", "IGK", "IGL"))
df[[i]] <- subset(df[[i]], productive %in% c(TRUE, "TRUE", "True", "true"))
#if (nrow(df[[i]]) == 0) { stop("There are 0 contigs
#        after internal filtering - check the contig list to see
#        if any issues exist for productive chains", call. = FALSE) }
df[[i]] <- df[[i]] %>% group_by(barcode,chain) %>% top_n(n=1,wt=reads)
df[[i]]$sample <- samples[i]
if (!is.null(ID)) {
df[[i]]$ID <- ID[i]
}
df[[i]] <- filteringMulti(df[[i]]) }
if (!is.null(samples)) {
out <- modifyBarcodes(df, samples, ID)
} else {
out <- df
}
for (i in seq_along(out)) {
data2 <- data.frame(out[[i]])
data2 <- makeGenes(cellType = "B", data2)
unique_df <- unique(data2$barcode)
Con.df <- data.frame(matrix(NA, length(unique_df), 9))
colnames(Con.df) <- c("barcode", heavy_lines, light_lines)
Con.df$barcode <- unique_df
Con.df <- parseBCR(Con.df, unique_df, data2)
Con.df <- assignCT(cellType = "B", Con.df)
data3<-Con.df %>% mutate(length1 = nchar(cdr3_nt1)) %>%
mutate(length2 = nchar(cdr3_nt2))
final[[i]] <- data3 }
dictionary <- bind_rows(final)
IGH <- lvCompare(dictionary, "IGH", "cdr3_nt1", threshold)
IGLC <- lvCompare(dictionary, "IGLC", "cdr3_nt2", threshold)
for(i in seq_along(final)) {
final[[i]]<-merge(final[[i]],IGH,by.x="cdr3_nt1",by.y="IG",all.x=TRUE)
final[[i]]<-merge(final[[i]],IGLC,by.x="cdr3_nt2",by.y="IG",all.x=TRUE)
num <- ncol(final[[i]])
final[[i]][,"CTstrict"] <- paste0(final[[i]][,num-1],"_",
final[[i]][,"vgene1"],"_",final[[i]][,num],"_",final[[i]][,"vgene2"])
final[[i]]$cellType <- "B"
final[[i]]$sample <- samples[i]
final[[i]]$ID <- ID[i]
final[[i]][final[[i]] == "NA_NA" | final[[i]] == "NA_NA_NA_NA"] <- NA
if (!is.null(sample) & !is.null(ID)) {
final[[i]]<- final[[i]][, c("barcode", "sample", "ID",
heavy_lines[c(1,2,3)], light_lines[c(1,2,3)], CT_lines)]
}
else if (!is.null(sample) & is.null(ID)) {
final[[i]]<- final[[i]][, c("barcode", "sample",
heavy_lines[c(1,2,3)], light_lines[c(1,2,3)], CT_lines)]
}
}
names <- NULL
for (i in seq_along(samples)) {
if (!is.null(sample) & !is.null(ID)) {
c <- paste(samples[i], "_", ID[i], sep="")
} else if (!is.null(sample) & is.null(ID)) {
c <- paste(samples[i], sep="")
}
names <- c(names, c)}
names(final) <- names
for (i in seq_along(final)) {
final[[i]] <- final[[i]][!duplicated(final[[i]]$barcode),]
final[[i]]<-final[[i]][rowSums(is.na(final[[i]])) < 10, ]}
if (removeNA == TRUE) { final <- removingNA(final) }
if (removeMulti == TRUE) { final <- removingMulti(final) }
return(final) }
combined <- combineBCR(contig.list, samples = c('BM','S','LN'))
View(combined)
df[[i]]$ID <- ID[i]
head(df[[i]])
setwd("~/Documents/GitHub/scRepertoire")
devtools::check()
devtools::check()
stop(
"There are 0 contigs after internal filtering -\n
check the contig list to see if any issues exist \n
for productive chains", call. = FALSE)
stop(
"There are 0 contigs after internal filtering -
check the contig list to see if any issues exist
for productive chains", call. = FALSE)
stop(
"There are 0 contigs after internal filtering -
/ncheck the contig list to see if any issues exist
/nfor productive chains", call. = FALSE)
stop(
"There are 0 contigs after internal filtering -
/n check the contig list to see if any issues exist
/n for productive chains", call. = FALSE)
stop(
"There are 0 contigs after internal filtering -
check the contig list to see if any issues exist
for productive chains", call. = FALSE)
stop(
"There are 0 contigs after internal filtering -
check the contig list to see if any issues exist
for productive chains", call. = FALSE)
devtools::document()
